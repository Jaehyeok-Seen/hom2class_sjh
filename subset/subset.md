# subset 핵심 개념

각 원소는 두가지 상태만 가질 수 있다.
0 : 부분집합에 포함되지 않는다.
1 : 부분집합에 포함된다.
그래서 range(2)는 각 원소에 대해 이 두가지 선택지 (0 또는 1)를 모두 시도하기 위함이다.

## 코드 동작 원리

4개 원소가 있다면:
1번째 원소: 포함(1) 또는 불포함(0) → 2가지 경우
2번째 원소: 포함(1) 또는 불포함(0) → 2가지 경우
3번째 원소: 포함(1) 또는 불포함(0) → 2가지 경우
4번째 원소: 포함(1) 또는 불포함(0) → 2가지 경우

총 경우의 수 = 2 × 2 × 2 × 2 = 2^4 = 16가지

### 코드 살펴보기
def print_subset(bit, elements=['A', 'B', 'C', 'D']):   # print_subset을 정의, 요소를 4가지 가진다고 제한
    subset = []                                         # subset을 빈리스트로 비워두고
    for i in range(4):                                  # 4가지 원소를 반복돌려서 
        if bit[i] == 1:                 # i는 인덱스(0,1,2,3)이고, 실제로 추가되는 것은 elements[i](A,B,C,D)입니다.
            subset.append(elements[i])                  # i를 빈리스트에 추가
    print(f"{bit} → {{{', '.join(subset) if subset else '∅'}}}")

# {{}}: 중괄호 자체를 출력하기 위한 이스케이프
# ', '.join(subset): 리스트를 쉼표로 연결
# if subset else '∅': 빈 집합일 때 공집합 기호

bit = [0,0,0,0]
print("모든 부분집합:")
for i in range(2):      # A 포함 여부
    bit[0] = i
    for j in range(2):  # B 포함 여부
        bit[1] = j
        for k in range(2):  # C 포함 여부
            bit[2] = k
            for l in range(2):  # D 포함 여부
                bit[3] = l
                print_subset(bit)

위 코드는 *비트마스킹*이라는 중요한 알고리즘 기법의 기초
- 각 비트가 원소의 포함/미포함을 나타냄
- 프로그래밍에서 부분집합 문제를 해결하는 핵심 방법

 # 질문1.  왜 0번째 피트는 별다른 설정없이 오른쪽부터 찾아가?

이건 컴퓨터의 기본 규칙입니다!

이진수:  1  0  1  1
비트위치: 3  2  1  0  ← 오른쪽부터 0번째!

이유: 최하위 비트(LSB)부터 시작
  #2^0, 2^1, 2^2, 2^3 순서
1011 = 1×2³ + 0×2² + 1×2¹ + 1×2⁰
     = 8    + 0    + 2    + 1 = 11

  #0번째 비트: 2^0의 자리 (가장 작은 자리값)
3번째 비트: 2^3의 자리 (가장 큰 자리값)

1 << 2의 단계별 분해
1단계: 시작점
1의 이진수 = 0001
2단계: << 2 (왼쪽으로 2칸 이동)
0001을 왼쪽으로 2칸 이동
0001 → 0010 → 0100
3단계: 결과
1 << 2 = 0100
시각적 이해
원래:    0 0 0 1
         ↑ ↑ ↑ ↑
위치:    3 2 1 0

2칸 왼쪽 이동 후:
         0 1 0 0
         ↑ ↑ ↑ ↑  
위치:    3 2 1 0
1이 0번째 위치에서 → 2번째 위치로 이동!
각 j값별 결과
python1 << 0 = 0001  # 1이 0번째 위치에
1 << 1 = 0010  # 1이 1번째 위치에  
1 << 2 = 0100  # 1이 2번째 위치에
1 << 3 = 1000  # 1이 3번째 위치에
실제 AND 연산
pythonj=2일 때:
5 & (1<<2) = 0101 & 0100
           = 0101
           & 0100
           ------
           = 0100 (0이 아닌 값 = True)
핵심: 1 << j는 j번째 위치에만 1이 있는 마스크를 만드는 것입니다!
이제 이해되시나요? 🎯